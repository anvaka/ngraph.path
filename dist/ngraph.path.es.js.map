{"version":3,"file":"ngraph.path.es.js","sources":["../a-star/NodeHeap.js","../a-star/makeSearchStatePool.js","../a-star/heuristics.js","../a-star/defaultSettings.js","../a-star/a-star.js","../a-star/a-greedy-star.js","../a-star/nba/makeNBASearchStatePool.js","../a-star/nba/index.js","../index.js"],"sourcesContent":["/**\n * Based on https://github.com/mourner/tinyqueue\n * Copyright (c) 2017, Vladimir Agafonkin https://github.com/mourner/tinyqueue/blob/master/LICENSE\n * \n * Adapted for PathFinding needs by @anvaka\n * Copyright (c) 2017, Andrei Kashcha\n */\nexport default function NodeHeap(data, options) {\n  if (!new.target) return new NodeHeap(data, options);\n\n  if (!Array.isArray(data)) {\n    // assume first argument is our config object;\n    options = data;\n    data = [];\n  }\n\n  options = options || {};\n\n  this.data = data || [];\n  this.length = this.data.length;\n  this.compare = options.compare || defaultCompare;\n  this.setNodeId = options.setNodeId || noop;\n\n  if (this.length > 0) {\n    for (var i = (this.length >> 1); i >= 0; i--) this._down(i);\n  }\n\n  if (options.setNodeId) {\n    for (var i = 0; i < this.length; ++i) {\n      this.setNodeId(this.data[i], i);\n    }\n  }\n}\n\nfunction noop() {}\n\nfunction defaultCompare(a, b) {\n  return a - b;\n}\n\nNodeHeap.prototype = {\n\n  push: function (item) {\n    this.data.push(item);\n    this.setNodeId(item, this.length);\n    this.length++;\n    this._up(this.length - 1);\n  },\n\n  pop: function () {\n    if (this.length === 0) return undefined;\n\n    var top = this.data[0];\n    this.length--;\n\n    if (this.length > 0) {\n      this.data[0] = this.data[this.length];\n      this.setNodeId(this.data[0], 0);\n      this._down(0);\n    }\n    this.data.pop();\n\n    return top;\n  },\n\n  peek: function () {\n    return this.data[0];\n  },\n\n  updateItem: function (pos) {\n    this._down(pos);\n    this._up(pos);\n  },\n\n  _up: function (pos) {\n    var data = this.data;\n    var compare = this.compare;\n    var setNodeId = this.setNodeId;\n    var item = data[pos];\n\n    while (pos > 0) {\n      var parent = (pos - 1) >> 1;\n      var current = data[parent];\n      if (compare(item, current) >= 0) break;\n        data[pos] = current;\n\n       setNodeId(current, pos);\n       pos = parent;\n    }\n\n    data[pos] = item;\n    setNodeId(item, pos);\n  },\n\n  _down: function (pos) {\n    var data = this.data;\n    var compare = this.compare;\n    var halfLength = this.length >> 1;\n    var item = data[pos];\n    var setNodeId = this.setNodeId;\n\n    while (pos < halfLength) {\n      var left = (pos << 1) + 1;\n      var right = left + 1;\n      var best = data[left];\n\n      if (right < this.length && compare(data[right], best) < 0) {\n        left = right;\n        best = data[right];\n      }\n      if (compare(best, item) >= 0) break;\n\n      data[pos] = best;\n      setNodeId(best, pos);\n      pos = left;\n    }\n\n    data[pos] = item;\n    setNodeId(item, pos);\n  }\n};","/**\n * This class represents a single search node in the exploration tree for\n * A* algorithm.\n * \n * @param {Object} node  original node in the graph\n */\nfunction NodeSearchState(node) {\n  this.node = node;\n\n  // How we came to this node?\n  this.parent = null;\n\n  this.closed = false;\n  this.open = 0;\n\n  this.distanceToSource = Number.POSITIVE_INFINITY;\n  // the f(n) = g(n) + h(n) value\n  this.fScore = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated.\n  this.heapIndex = -1;\n};\n\nexport default function makeSearchStatePool() {\n  var currentInCache = 0;\n  var nodeCache = [];\n\n  return {\n    createNewState: createNewState,\n    reset: reset\n  };\n\n  function reset() {\n    currentInCache = 0;\n  }\n\n  function createNewState(node) {\n    var cached = nodeCache[currentInCache];\n    if (cached) {\n      // TODO: This almost duplicates constructor code. Not sure if\n      // it would impact performance if I move this code into a function\n      cached.node = node;\n      // How we came to this node?\n      cached.parent = null;\n\n      cached.closed = false;\n      cached.open = 0;\n\n      cached.distanceToSource = Number.POSITIVE_INFINITY;\n      // the f(n) = g(n) + h(n) value\n      cached.fScore = Number.POSITIVE_INFINITY;\n\n      // used to reconstruct heap when fScore is updated.\n      cached.heapIndex = -1;\n\n    } else {\n      cached = new NodeSearchState(node);\n      nodeCache[currentInCache] = cached;\n    }\n    currentInCache++;\n    return cached;\n  }\n}","export { l2, l1 };\n\n/**\n * Euclid distance (l2 norm);\n * \n * @param {*} a \n * @param {*} b \n */\nfunction l2(a, b) {\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Manhattan distance (l1 norm);\n * @param {*} a \n * @param {*} b \n */\nfunction l1(a, b) {\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.abs(dx) + Math.abs(dy);\n}\n","// We reuse instance of array, but we trie to freeze it as well,\n// so that consumers don't modify it. Maybe it's a bad idea.\nconst NO_PATH = [];\nif (typeof Object.freeze === 'function') Object.freeze(NO_PATH);\n\nconst defaultSettings = {\n  // Path search settings\n  heuristic: blindHeuristic,\n  distance: constantDistance,\n  blocked: neverBlocked,\n  compareFScore: compareFScore,\n  NO_PATH: NO_PATH,\n\n  // heap settings\n  setHeapIndex: setHeapIndex,\n\n  // nba:\n  setH1: setH1,\n  setH2: setH2,\n  compareF1Score: compareF1Score,\n  compareF2Score: compareF2Score,\n};\n\nexport default defaultSettings;\n\nfunction blindHeuristic(/* a, b */) {\n  // blind heuristic makes this search equal to plain Dijkstra path search.\n  return 0;\n}\n\nfunction constantDistance(/* a, b */) {\n  return 1;\n}\n\nfunction neverBlocked(/* a, b, c */) {\n  return false;\n}\n\nfunction compareFScore(a, b) {\n  var result = a.fScore - b.fScore;\n  // TODO: Can I improve speed with smarter ties-breaking?\n  // I tried distanceToSource, but it didn't seem to have much effect\n  return result;\n}\n\nfunction setHeapIndex(nodeSearchState, heapIndex) {\n  nodeSearchState.heapIndex = heapIndex;\n}\n\nfunction compareF1Score(a, b) {\n  return a.f1 - b.f1;\n}\n\nfunction compareF2Score(a, b) {\n  return a.f2 - b.f2;\n}\n\nfunction setH1(node, heapIndex) {\n  node.h1 = heapIndex;\n}\n\nfunction setH2(node, heapIndex) {\n  node.h2 = heapIndex;\n}","/**\n * Performs a uni-directional A Star search on graph.\n * \n * We will try to minimize f(n) = g(n) + h(n), where\n * g(n) is actual distance from source node to `n`, and\n * h(n) is heuristic distance from `n` to target node.\n */\nimport NodeHeap from './NodeHeap.js';\nimport makeSearchStatePool from './makeSearchStatePool.js';\nimport * as heuristics from './heuristics.js';\nimport defaultSettings from './defaultSettings.js';\n\nvar NO_PATH = defaultSettings.NO_PATH;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b, link)} options.blocked - a function that returns `true` if the link between \n * nodes `a` and `b` are blocked paths. This function is useful for temporarily blocking routes \n * while allowing the graph to be reused without rebuilding.\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarPathSearch(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n\n  var blocked = options.blocked;\n  if (!blocked) blocked = defaultSettings.blocked;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n\n  function find(fromId, toId) {\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n    pool.reset();\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    // the nodes that we still need to evaluate\n    var openSet = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSet.push(startNode);\n    startNode.open = 1;\n\n    var cameFrom;\n\n    while (openSet.length > 0) {\n      cameFrom = openSet.pop();\n      if (goalReached(cameFrom, to)) return reconstructPath(cameFrom);\n\n      // no need to visit this node anymore\n      cameFrom.closed = true;\n      graph.forEachLinkedNode(cameFrom.node.id, visitNeighbour, oriented);\n    }\n\n    // If we got here, then there is no path.\n    return NO_PATH;\n\n    function visitNeighbour(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n      if (otherSearchState.open === 0) {\n        // Remember this node.\n        openSet.push(otherSearchState);\n        otherSearchState.open = 1;\n      }\n\n      if (blocked(otherNode, cameFrom.node, link)) {\n        // Path is blocked. Ignore this route\n        return;\n      }\n\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherNode, cameFrom.node, link);\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n      otherSearchState.fScore = tentativeDistance + heuristic(otherSearchState.node, to);\n\n      openSet.updateItem(otherSearchState.heapIndex);\n    }\n  }\n}\n\naStarPathSearch.l2 = heuristics.l2;\naStarPathSearch.l1 = heuristics.l1;\n\nexport default aStarPathSearch;\n\nfunction goalReached(searchState, targetNode) {\n  return searchState.node === targetNode;\n}\n\nfunction reconstructPath(searchState) {\n  var path = [searchState.node];\n  var parent = searchState.parent;\n\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.parent;\n  }\n\n  return path;\n}\n","/**\n * Performs suboptimal, greed A Star path finding.\n * This finder does not necessary finds the shortest path. The path\n * that it finds is very close to the shortest one. It is very fast though.\n */\nimport NodeHeap from './NodeHeap.js';\nimport makeSearchStatePool from './makeSearchStatePool.js';\nimport * as heuristics from './heuristics.js';\nimport defaultSettings from './defaultSettings.js';\n\nvar BY_FROM = 1;\nvar BY_TO = 2;\nvar NO_PATH = defaultSettings.NO_PATH;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * NOTE: Algorithm implemented in this code DOES NOT find optimal path.\n * Yet the path that it finds is always near optimal, and it finds it very fast.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * \n * @param {Object} options that configures search\n * @param {Function(a, b, link)} options.blocked - a function that returns `true` if the link between \n * nodes `a` and `b` are blocked paths. This function is useful for temporarily blocking routes \n * while allowing the graph to be reused without rebuilding.\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`.  Defaults function returns 0, which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarBi(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n\n  var blocked = options.blocked;\n  if (!blocked) blocked = defaultSettings.blocked;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n\n  return {\n    find: find\n  };\n\n  function find(fromId, toId) {\n    // Not sure if we should return NO_PATH or throw. Throw seem to be more\n    // helpful to debug errors. So, throwing.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n\n    if (from === to) return [from]; // trivial case.\n\n    pool.reset();\n\n    var callVisitor = oriented ? orientedVisitor : nonOrientedVisitor;\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    var openSetFrom = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n    var openSetTo = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSetFrom.push(startNode);\n    startNode.open = BY_FROM;\n\n    var endNode = pool.createNewState(to);\n    endNode.fScore = heuristic(to, from);\n    endNode.distanceToSource = 0;\n    openSetTo.push(endNode);\n    endNode.open = BY_TO;\n\n    // Cost of the best solution found so far. Used for accurate termination\n    var lMin = Number.POSITIVE_INFINITY;\n    var minFrom;\n    var minTo;\n\n    var currentSet = openSetFrom;\n    var currentOpener = BY_FROM;\n\n    while (openSetFrom.length > 0 && openSetTo.length > 0) {\n      if (openSetFrom.length < openSetTo.length) {\n        // we pick a set with less elements\n        currentOpener = BY_FROM;\n        currentSet = openSetFrom;\n      } else {\n        currentOpener = BY_TO;\n        currentSet = openSetTo;\n      }\n\n      var current = currentSet.pop();\n\n      // no need to visit this node anymore\n      current.closed = true;\n\n      if (current.distanceToSource > lMin) continue;\n\n      graph.forEachLinkedNode(current.node.id, callVisitor);\n\n      if (minFrom && minTo) {\n        // This is not necessary the best path, but we are so greedy that we\n        // can't resist:\n        return reconstructBiDirectionalPath(minFrom, minTo);\n      }\n    }\n\n    return NO_PATH; // No path.\n\n    function nonOrientedVisitor(otherNode, link) {\n      return visitNode(otherNode, link, current);\n    }\n\n    function orientedVisitor(otherNode, link) {\n      // For oritned graphs we need to reverse graph, when traveling\n      // backwards. So, we use non-oriented ngraph's traversal, and \n      // filter link orientation here.\n      if (currentOpener === BY_FROM) {\n        if (link.fromId === current.node.id) return visitNode(otherNode, link, current)\n      } else if (currentOpener === BY_TO) {\n        if (link.toId === current.node.id) return visitNode(otherNode, link, current);\n      }\n    }\n\n    function canExit(currentNode) {\n      var opener = currentNode.open\n      if (opener && opener !== currentOpener) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function reconstructBiDirectionalPath(a, b) {\n      var pathOfNodes = [];\n      var aParent = a;\n      while(aParent) {\n        pathOfNodes.push(aParent.node);\n        aParent = aParent.parent;\n      }\n      var bParent = b;\n      while (bParent) {\n        pathOfNodes.unshift(bParent.node);\n        bParent = bParent.parent\n      }\n      return pathOfNodes;\n    }\n\n    function visitNode(otherNode, link, cameFrom) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n\n      if (blocked(otherSearchState.node, cameFrom.node, link)) {\n        // Path is blocked. Ignore this route\n        return;\n      }\n\n      if (canExit(otherSearchState, cameFrom)) {\n        // this node was opened by alternative opener. The sets intersect now,\n        // we found an optimal path, that goes through *this* node. However, there\n        // is no guarantee that this is the global optimal solution path.\n\n        var potentialLMin = otherSearchState.distanceToSource + cameFrom.distanceToSource;\n        if (potentialLMin < lMin) {\n          minFrom = otherSearchState;\n          minTo = cameFrom\n          lMin = potentialLMin;\n        }\n        // we are done with this node.\n        return;\n      }\n\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherSearchState.node, cameFrom.node, link);\n\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // Choose target based on current working set:\n      var target = (currentOpener === BY_FROM) ? to : from;\n      var newFScore = tentativeDistance + heuristic(otherSearchState.node, target);\n      if (newFScore >= lMin) {\n        // this can't be optimal path, as we have already found a shorter path.\n        return;\n      }\n      otherSearchState.fScore = newFScore;\n\n      if (otherSearchState.open === 0) {\n        // Remember this node in the current set\n        currentSet.push(otherSearchState);\n        currentSet.updateItem(otherSearchState.heapIndex);\n\n        otherSearchState.open = currentOpener;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n    }\n  }\n}\n\naStarBi.l2 = heuristics.l2;\naStarBi.l1 = heuristics.l1;\n\nexport default aStarBi;\n","/**\n * Creates new instance of NBASearchState. The instance stores information\n * about search state, and is used by NBA* algorithm.\n *\n * @param {Object} node - original graph node\n */\nfunction NBASearchState(node) {\n  /**\n   * Original graph node.\n   */\n  this.node = node;\n\n  /**\n   * Parent of this node in forward search\n   */\n  this.p1 = null;\n\n  /**\n   * Parent of this node in reverse search\n   */\n  this.p2 = null;\n\n  /**\n   * If this is set to true, then the node was already processed\n   * and we should not touch it anymore.\n   */\n  this.closed = false;\n\n  /**\n   * Actual distance from this node to its parent in forward search\n   */\n  this.g1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Actual distance from this node to its parent in reverse search\n   */\n  this.g2 = Number.POSITIVE_INFINITY;\n\n\n  /**\n   * Underestimated distance from this node to the path-finding source.\n   */\n  this.f1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Underestimated distance from this node to the path-finding target.\n   */\n  this.f2 = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated. TODO: do I need them both?\n\n  /**\n   * Index of this node in the forward heap.\n   */\n  this.h1 = -1;\n\n  /**\n   * Index of this node in the reverse heap.\n   */\n  this.h2 = -1;\n}\n\n/**\n * As path-finding is memory-intensive process, we want to reduce pressure on\n * garbage collector. This class helps us to recycle path-finding nodes and significantly\n * reduces the search time (~20% faster than without it).\n */\nexport default function makeNBASearchStatePool() {\n  var currentInCache = 0;\n  var nodeCache = [];\n\n  return {\n    /**\n     * Creates a new NBASearchState instance\n     */\n    createNewState: createNewState,\n\n    /**\n     * Marks all created instances available for recycling.\n     */\n    reset: reset\n  };\n\n  function reset() {\n    currentInCache = 0;\n  }\n\n  function createNewState(node) {\n    var cached = nodeCache[currentInCache];\n    if (cached) {\n      // TODO: This almost duplicates constructor code. Not sure if\n      // it would impact performance if I move this code into a function\n      cached.node = node;\n\n      // How we came to this node?\n      cached.p1 = null;\n      cached.p2 = null;\n\n      cached.closed = false;\n\n      cached.g1 = Number.POSITIVE_INFINITY;\n      cached.g2 = Number.POSITIVE_INFINITY;\n      cached.f1 = Number.POSITIVE_INFINITY;\n      cached.f2 = Number.POSITIVE_INFINITY;\n\n      // used to reconstruct heap when fScore is updated.\n      cached.h1 = -1;\n      cached.h2 = -1;\n    } else {\n      cached = new NBASearchState(node);\n      nodeCache[currentInCache] = cached;\n    }\n    currentInCache++;\n    return cached;\n  }\n}\n","import NodeHeap from '../NodeHeap.js';\nimport * as heuristics from '../heuristics.js';\nimport defaultSettings from '../defaultSettings.js';\nimport makeNBASearchStatePool from './makeNBASearchStatePool.js';\n\nvar NO_PATH = defaultSettings.NO_PATH;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`.\n * \n * This is implementation of the NBA* algorithm described in \n * \n *  \"Yet another bidirectional algorithm for shortest paths\" paper by Wim Pijls and Henk Post\n * \n * The paper is available here: https://repub.eur.nl/pub/16100/ei2009-10.pdf\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b, link)} options.blocked - a function that returns `true` if the link between \n * nodes `a` and `b` are blocked paths. This function is useful for temporarily blocking routes \n * while allowing the graph to be reused without rebuilding.\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction nba(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n  var quitFast = options.quitFast;\n\n  var blocked = options.blocked;\n  if (!blocked) blocked = defaultSettings.blocked;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n\n  // During stress tests I noticed that garbage collection was one of the heaviest\n  // contributors to the algorithm's speed. So I'm using an object pool to recycle nodes.\n  var pool = makeNBASearchStatePool();\n\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n\n  function find(fromId, toId) {\n    // I must apologize for the code duplication. This was the easiest way for me to\n    // implement the algorithm fast.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n\n    pool.reset();\n\n    // I must also apologize for somewhat cryptic names. The NBA* is bi-directional\n    // search algorithm, which means it runs two searches in parallel. One is called\n    // forward search and it runs from source node to target, while the other one\n    // (backward search) runs from target to source.\n\n    // Everywhere where you see `1` it means it's for the forward search. `2` is for \n    // backward search.\n\n    // For oriented graph path finding, we need to reverse the graph, so that\n    // backward search visits correct link. Obviously we don't want to duplicate\n    // the graph, instead we always traverse the graph as non-oriented, and filter\n    // edges in `visitN1Oriented/visitN2Oritented`\n    var forwardVisitor = oriented ? visitN1Oriented : visitN1;\n    var reverseVisitor = oriented ? visitN2Oriented : visitN2;\n\n    // Maps nodeId to NBASearchState.\n    var nodeState = new Map();\n\n    // These two heaps store nodes by their underestimated values.\n    var open1Set = new NodeHeap({\n      compare: defaultSettings.compareF1Score,\n      setNodeId: defaultSettings.setH1\n    });\n    var open2Set = new NodeHeap({\n      compare: defaultSettings.compareF2Score,\n      setNodeId: defaultSettings.setH2\n    });\n\n    // This is where both searches will meet.\n    var minNode;\n\n    // The smallest path length seen so far is stored here:\n    var lMin = Number.POSITIVE_INFINITY;\n\n    // We start by putting start/end nodes to the corresponding heaps\n    // If variable names like `f1`, `g1` are too confusing, please refer\n    // to makeNBASearchStatePool.js file, which has detailed description.\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode); \n    startNode.g1 = 0;\n    var f1 = heuristic(from, to);\n    startNode.f1 = f1;\n    open1Set.push(startNode);\n\n    var endNode = pool.createNewState(to);\n    nodeState.set(toId, endNode);\n    endNode.g2 = 0;\n    var f2 = f1; // they should agree originally\n    endNode.f2 = f2;\n    open2Set.push(endNode)\n\n    // the `cameFrom` variable is accessed by both searches, so that we can store parents.\n    var cameFrom;\n\n    // this is the main algorithm loop:\n    while (open2Set.length && open1Set.length) {\n      if (open1Set.length < open2Set.length) {\n        forwardSearch();\n      } else {\n        reverseSearch();\n      }\n\n      if (quitFast && minNode) break;\n    }\n\n    var path = reconstructPath(minNode);\n    return path; // the public API is over\n\n    function forwardSearch() {\n      cameFrom = open1Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n\n      cameFrom.closed = true;\n\n      if (cameFrom.f1 < lMin && (cameFrom.g1 + f2 - heuristic(from, cameFrom.node)) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, forwardVisitor);\n      }\n\n      if (open1Set.length > 0) {\n        // this will be used in reverse search\n        f1 = open1Set.peek().f1;\n      } \n    }\n\n    function reverseSearch() {\n      cameFrom = open2Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n      cameFrom.closed = true;\n\n      if (cameFrom.f2 < lMin && (cameFrom.g2 + f1 - heuristic(cameFrom.node, to)) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, reverseVisitor);\n      }\n\n      if (open2Set.length > 0) {\n        // this will be used in forward search\n        f2 = open2Set.peek().f2;\n      }\n    }\n\n    function visitN1(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) return;\n\n      if (blocked(cameFrom.node, otherNode, link)) return;\n\n      var tentativeDistance = cameFrom.g1 + distance(cameFrom.node, otherNode, link);\n\n      if (tentativeDistance < otherSearchState.g1) {\n        otherSearchState.g1 = tentativeDistance;\n        otherSearchState.f1 = tentativeDistance + heuristic(otherSearchState.node, to);\n        otherSearchState.p1 = cameFrom;\n        if (otherSearchState.h1 < 0) {\n          open1Set.push(otherSearchState);\n        } else {\n          open1Set.updateItem(otherSearchState.h1);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) { \n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n\n    function visitN2(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) return;\n\n      if (blocked(cameFrom.node, otherNode, link)) return;\n\n      var tentativeDistance = cameFrom.g2 + distance(cameFrom.node, otherNode, link);\n\n      if (tentativeDistance < otherSearchState.g2) {\n        otherSearchState.g2 = tentativeDistance;\n        otherSearchState.f2 = tentativeDistance + heuristic(from, otherSearchState.node);\n        otherSearchState.p2 = cameFrom;\n        if (otherSearchState.h2 < 0) {\n          open2Set.push(otherSearchState);\n        } else {\n          open2Set.updateItem(otherSearchState.h2);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) {\n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n\n    function visitN2Oriented(otherNode, link) {\n      // we are going backwards, graph needs to be reversed. \n      if (link.toId === cameFrom.node.id) return visitN2(otherNode, link);\n    }\n    function visitN1Oriented(otherNode, link) {\n      // this is forward direction, so we should be coming FROM:\n      if (link.fromId === cameFrom.node.id) return visitN1(otherNode, link);\n    }\n  }\n}\n\nnba.l2 = heuristics.l2;\nnba.l1 = heuristics.l1;\n\nexport default nba;\n\nfunction reconstructPath(searchState) {\n  if (!searchState) return NO_PATH;\n\n  var path = [searchState.node];\n  var parent = searchState.p1;\n\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.p1;\n  }\n\n  var child = searchState.p2;\n\n  while (child) {\n    path.unshift(child.node);\n    child = child.p2;\n  }\n  return path;\n}\n","import aStar from './a-star/a-star.js';\nimport aGreedy from './a-star/a-greedy-star.js';\nimport nba from './a-star/nba/index.js';\n\nconst pathFinders = {\n  aStar,\n  aGreedy,\n  nba,\n};\n\nexport { aStar, aGreedy, nba };\nexport default pathFinders;\n"],"names":["NodeHeap","data","options","defaultCompare","noop","i","a","b","item","top","pos","compare","setNodeId","parent","current","halfLength","left","right","best","NodeSearchState","node","makeSearchStatePool","currentInCache","nodeCache","createNewState","reset","cached","l2","dx","dy","l1","NO_PATH","defaultSettings","blindHeuristic","constantDistance","neverBlocked","compareFScore","setHeapIndex","setH1","setH2","compareF1Score","compareF2Score","result","nodeSearchState","heapIndex","aStarPathSearch","graph","oriented","blocked","heuristic","distance","pool","find","fromId","toId","from","to","nodeState","openSet","startNode","cameFrom","goalReached","reconstructPath","visitNeighbour","otherNode","link","otherSearchState","tentativeDistance","heuristics.l2","heuristics.l1","searchState","targetNode","path","BY_FROM","BY_TO","aStarBi","callVisitor","orientedVisitor","nonOrientedVisitor","openSetFrom","openSetTo","endNode","lMin","minFrom","minTo","currentSet","currentOpener","reconstructBiDirectionalPath","visitNode","canExit","currentNode","opener","pathOfNodes","aParent","bParent","potentialLMin","target","newFScore","NBASearchState","makeNBASearchStatePool","nba","quitFast","forwardVisitor","visitN1Oriented","visitN1","reverseVisitor","visitN2Oriented","visitN2","open1Set","open2Set","minNode","f1","f2","forwardSearch","reverseSearch","potentialMin","child","pathFinders","aStar","aGreedy"],"mappings":"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"}